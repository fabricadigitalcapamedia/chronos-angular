{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\nclass NGXLoggerConfigEngine {\n  constructor(config) {\n    this.config = this._clone(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n  get level() {\n    return this.config.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n  get serverLogLevel() {\n    return this.config.serverLogLevel;\n  }\n  updateConfig(config) {\n    this.config = this._clone(config);\n  }\n  /** Update the config partially\r\n   * This is useful if you want to update only one parameter of the config\r\n   */\n  partialUpdateConfig(partialConfig) {\n    // avoid any error if the config is incorrect\n    if (!partialConfig) {\n      return;\n    }\n    Object.keys(partialConfig).forEach(configParamKey => {\n      this.config[configParamKey] = partialConfig[configParamKey];\n    });\n  }\n  getConfig() {\n    return this._clone(this.config);\n  }\n  // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\n  _clone(object) {\n    const cloneConfig = {\n      level: null\n    };\n    Object.keys(object).forEach(key => {\n      cloneConfig[key] = object[key];\n    });\n    return cloneConfig;\n  }\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\nclass NGXLoggerConfigEngineFactory {\n  provideConfigEngine(config) {\n    return new NGXLoggerConfigEngine(config);\n  }\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\nclass NGXLoggerMapperService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n    /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\n    this.sourceMapCache = new Map();\n    /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\n    this.logPositionCache = new Map();\n  }\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config\r\n   * @param metadata\r\n   * @returns\r\n   */\n  getLogPosition(config, metadata) {\n    const stackLine = this.getStackLine(config);\n    // if we were not able to parse the stackLine, just return an empty Log Position\n    if (!stackLine) {\n      return of({\n        fileName: '',\n        lineNumber: 0,\n        columnNumber: 0\n      });\n    }\n    const logPosition = this.getLocalPosition(stackLine);\n    if (!config.enableSourceMaps) {\n      return of(logPosition);\n    }\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\n    return this.getSourceMap(sourceMapLocation, logPosition);\n  }\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config\r\n   * @returns null if stackline was not found\r\n   */\n  getStackLine(config) {\n    const error = new Error();\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      try {\n        // Here are different examples of stacktrace \n        // Firefox (last line is the user code, the 4 first are ours):\n        // getStackLine@http://localhost:4200/main.js:358:23\n        // getCallerDetails@http://localhost:4200/main.js:557:44\n        // _log@http://localhost:4200/main.js:830:28\n        // debug@http://localhost:4200/main.js:652:14\n        // handleLog@http://localhost:4200/main.js:1158:29\n        // Chrome and Edge (last line is the user code):\n        // Error\n        // at Function.getStackLine (ngx-logger.js:329)\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\n        // at NGXLogger._log (ngx-logger.js:801)\n        // at NGXLogger.info (ngx-logger.js:631)\n        // at AppComponent.handleLog (app.component.ts:38)\n        let defaultProxy = 4; // We make 4 functions call before getting here\n        const firstStackLine = error.stack.split('\\n')[0];\n        if (!firstStackLine.includes('.js:')) {\n          // The stacktrace starts with no function call (example in Chrome or Edge)\n          defaultProxy = defaultProxy + 1;\n        }\n        return error.stack.split('\\n')[defaultProxy + (config.proxiedSteps || 0)];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine\r\n   * @returns\r\n   */\n  getLocalPosition(stackLine) {\n    // strip base path, then parse filename, line, and column, stackline looks like this :\n    // Firefox\n    // handleLog@http://localhost:4200/main.js:1158:29\n    // Chrome and Edge\n    // at AppComponent.handleLog (app.component.ts:38)\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n    if (dataArray.length === 3) {\n      return {\n        fileName: dataArray[0],\n        lineNumber: +dataArray[1],\n        columnNumber: +dataArray[2]\n      };\n    }\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  getTranspileLocation(stackLine) {\n    // Example stackLine:\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\n    let locationStartIndex = stackLine.indexOf('(');\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf('@');\n      if (locationStartIndex < 0) {\n        locationStartIndex = stackLine.lastIndexOf(' ');\n      }\n    }\n    let locationEndIndex = stackLine.indexOf(')');\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine\r\n   * @returns\r\n   */\n  getSourceMapLocation(stackLine) {\n    const file = this.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n  getMapping(sourceMap, position) {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,\n      // second field\n      sourceCodeLine = 0,\n      // third field\n      sourceCodeColumn = 0; // fourth field\n    const lines = sourceMap.mappings.split(';');\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0;\n      // decode sections in line\n      const columns = lines[lineIndex].split(',');\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        }\n        // check if matching map\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: sourceCodeColumn\n            };\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: 0\n            };\n          }\n        }\n      }\n    }\n    // failed if reached\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\n  getSourceMap(sourceMapLocation, distPosition) {\n    const req = new HttpRequest('GET', sourceMapLocation);\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\n    // if the specific log position is already in cache return it\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    }\n    // otherwise check if the source map is already cached for given source map location\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      if (!this.httpBackend) {\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\n        this.sourceMapCache.set(sourceMapLocation, of(null));\n      } else {\n        // obtain the source map if not cached\n        this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body), retry(3), shareReplay(1)));\n      }\n    }\n    // at this point the source map is cached, use it to get specific log position mapping\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map(sourceMap => {\n      // sourceMap can be null if HttpBackend is not provided for example\n      if (!sourceMap) {\n        return distPosition;\n      }\n      // map generated position to source position\n      return this.getMapping(sourceMap, distPosition);\n    }), catchError(() => of(distPosition)), shareReplay(1));\n    // store specific log position in cache for given dest position and return it\n    this.logPositionCache.set(distPositionKey, logPosition$);\n    return logPosition$;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMapperService.ɵfac = function NGXLoggerMapperService_Factory(t) {\n  return new (t || NGXLoggerMapperService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMapperService,\n  factory: NGXLoggerMapperService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * Injection token of logger metadata service\r\n */\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\nclass NGXLoggerMetadataService {\n  constructor(datePipe) {\n    this.datePipe = datePipe;\n  }\n  computeTimestamp(config) {\n    const defaultTimestamp = () => new Date().toISOString();\n    if (config.timestampFormat) {\n      if (!this.datePipe) {\n        console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\n        return defaultTimestamp();\n      } else {\n        return this.datePipe.transform(new Date(), config.timestampFormat);\n      }\n    }\n    return defaultTimestamp();\n  }\n  getMetadata(level, config, message, additional) {\n    const metadata = {\n      level: level,\n      additional: additional\n    };\n    // The user can send a function\n    // This is useful in order to compute string concatenation only when the log will actually be written\n    if (message && typeof message === 'function') {\n      metadata.message = message();\n    } else {\n      metadata.message = message;\n    }\n    metadata.timestamp = this.computeTimestamp(config);\n    return metadata;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMetadataService.ɵfac = function NGXLoggerMetadataService_Factory(t) {\n  return new (t || NGXLoggerMetadataService)(i0.ɵɵinject(i1$1.DatePipe, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerMetadataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMetadataService,\n  factory: NGXLoggerMetadataService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1$1.DatePipe,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n// I kept this class alive only to avoid a breaking change with the old version\n// This class does not implement anything so it is useless and the interface is enough\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\nclass NGXLoggerMonitor {}\n\n/**\r\n * Injection token of logger metadata service\r\n */\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\nclass NGXLoggerRulesService {\n  shouldCallWriter(level, config, message, additional) {\n    return !config.disableConsoleLogging && level >= config.level;\n  }\n  shouldCallServer(level, config, message, additional) {\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\n  }\n  shouldCallMonitor(level, config, message, additional) {\n    // The default behavior is to call the monitor only if the writer or the server is called\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerRulesService.ɵfac = function NGXLoggerRulesService_Factory(t) {\n  return new (t || NGXLoggerRulesService)();\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerRulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerRulesService,\n  factory: NGXLoggerRulesService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesService, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\r\n * Injection token of logger server service\r\n */\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\nclass NGXLoggerServerService {\n  constructor(httpBackend, ngZone) {\n    this.httpBackend = httpBackend;\n    this.ngZone = ngZone;\n    this.serverCallsQueue = [];\n    this.flushingQueue = new BehaviorSubject(false);\n  }\n  ngOnDestroy() {\n    if (this.flushingQueue) {\n      this.flushingQueue.complete();\n      this.flushingQueue = null;\n    }\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n  }\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\n  secureErrorObject(err) {\n    return err?.stack;\n  }\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\n  secureAdditionalParameters(additional) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n    return additional.map((next, idx) => {\n      try {\n        if (next instanceof Error) {\n          return this.secureErrorObject(next);\n        }\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\n  secureMessage(message) {\n    try {\n      if (message instanceof Error) {\n        return this.secureErrorObject(message);\n      }\n      if (typeof message !== 'string') {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n    return message;\n  }\n  /**\r\n   * Edits HttpRequest object before sending request to server\r\n   * @param httpRequest default request object\r\n   * @returns altered httprequest\r\n   */\n  alterHttpRequest(httpRequest) {\n    return httpRequest;\n  }\n  /**\r\n   * Sends request to server\r\n   * @param url\r\n   * @param logContent\r\n   * @param options\r\n   * @returns\r\n   */\n  logOnServer(url, logContent, options) {\n    if (!this.httpBackend) {\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\n      return of(null);\n    }\n    // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n    let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\n    let finalRequest = of(defaultRequest);\n    const alteredRequest = this.alterHttpRequest(defaultRequest);\n    if (isObservable(alteredRequest)) {\n      finalRequest = alteredRequest;\n    } else if (alteredRequest) {\n      finalRequest = of(alteredRequest);\n    } else {\n      console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\n    }\n    return finalRequest.pipe(concatMap(req => {\n      if (!req) {\n        console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\n        return this.httpBackend.handle(defaultRequest);\n      }\n      return this.httpBackend.handle(req);\n    }), filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body));\n  }\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\n  customiseRequestBody(metadata) {\n    // In our API the body is not customised\n    return metadata;\n  }\n  /**\r\n   * Flush the queue of the logger\r\n   * @param config\r\n   */\n  flushQueue(config) {\n    this.flushingQueue.next(true);\n    // If a timer was set, we cancel it because the queue is flushed\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n    if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\n      this.sendToServerAction(this.serverCallsQueue, config);\n    }\n    this.serverCallsQueue = [];\n    this.flushingQueue.next(false);\n  }\n  sendToServerAction(metadata, config) {\n    let requestBody;\n    const secureMetadata = pMetadata => {\n      // Copying metadata locally because we don't want to change the object for the caller\n      const securedMetadata = {\n        ...pMetadata\n      };\n      securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\n      securedMetadata.message = this.secureMessage(securedMetadata.message);\n      return securedMetadata;\n    };\n    if (Array.isArray(metadata)) {\n      requestBody = [];\n      metadata.forEach(m => {\n        requestBody.push(secureMetadata(m));\n      });\n    } else {\n      requestBody = secureMetadata(metadata);\n    }\n    // Allow users to customise the data sent to the API\n    requestBody = this.customiseRequestBody(requestBody);\n    const headers = config.customHttpHeaders || new HttpHeaders();\n    if (!headers.has('Content-Type')) {\n      headers.set('Content-Type', 'application/json');\n    }\n    const logOnServerAction = () => {\n      this.logOnServer(config.serverLoggingUrl, requestBody, {\n        headers,\n        params: config.customHttpParams || new HttpParams(),\n        responseType: config.httpResponseType || 'json',\n        withCredentials: config.withCredentials || false\n      }).pipe(catchError(err => {\n        // Do not use NGXLogger here because this could cause an infinite loop \n        console.error('NGXLogger: Failed to log on server', err);\n        return throwError(err);\n      })).subscribe();\n    };\n    if (config.serverCallsOutsideNgZone === true) {\n      if (!this.ngZone) {\n        console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\n        return;\n      }\n      this.ngZone.runOutsideAngular(logOnServerAction);\n    } else {\n      logOnServerAction();\n    }\n  }\n  /**\r\n   * Sends the content to be logged to the server according to the config\r\n   * @param metadata\r\n   * @param config\r\n   */\n  sendToServer(metadata, config) {\n    // If there is no batch mode in the config, we send the log call straight to the server as usual\n    if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) && (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\n      this.sendToServerAction(metadata, config);\n      return;\n    }\n    const addLogToQueueAction = () => {\n      this.serverCallsQueue.push({\n        ...metadata\n      });\n      // Flush queue when size is reached\n      if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\n        this.flushQueue(config);\n      }\n      // Call timer only if it is in the config and timer is not already running\n      if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\n        this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\n          this.flushQueue(config);\n        });\n      }\n    };\n    // If queue is being flushed, we need to wait for it to finish before adding other calls\n    if (this.flushingQueue.value === true) {\n      this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\n        addLogToQueueAction();\n      });\n    } else {\n      addLogToQueueAction();\n    }\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) {\n  return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8), i0.ɵɵinject(i0.NgZone, 8));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerServerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerServerService,\n  factory: NGXLoggerServerService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i0.NgZone,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * Injection token of logger writer service\r\n */\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\nvar NgxLoggerLevel;\n(function (NgxLoggerLevel) {\n  NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\n  NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\n  NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\n  NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\n  NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\n  NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\nconst DEFAULT_COLOR_SCHEME = ['purple', 'teal', 'gray', 'gray', 'red', 'red', 'red'];\nclass NGXLoggerWriterService {\n  constructor(platformId) {\n    this.platformId = platformId;\n    /** List of functions called when preparing meta string */\n    this.prepareMetaStringFuncs = [this.getTimestampToWrite, this.getLevelToWrite, this.getFileDetailsToWrite, this.getContextToWrite];\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent && !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\n  }\n  getTimestampToWrite(metadata, config) {\n    return metadata.timestamp;\n  }\n  getLevelToWrite(metadata, config) {\n    return NgxLoggerLevel[metadata.level];\n  }\n  getFileDetailsToWrite(metadata, config) {\n    return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\n  }\n  getContextToWrite(metadata, config) {\n    return config.context ? `{${config.context}}` : '';\n  }\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\n  prepareMetaString(metadata, config) {\n    let metaString = '';\n    this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\n      const metaItem = prepareMetaStringFunc(metadata, config);\n      if (metaItem) {\n        metaString = metaString + ' ' + metaItem;\n      }\n    });\n    return metaString.trim();\n  }\n  /** Get the color to use when writing to console */\n  getColor(metadata, config) {\n    const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\n    // this is needed to avoid a build error\n    if (metadata.level === NgxLoggerLevel.OFF) {\n      return undefined;\n    }\n    return configColorScheme[metadata.level];\n  }\n  /** Log to the console specifically for IE */\n  logIE(metadata, config, metaString) {\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, metadata.message, ...additional);\n        break;\n      default:\n        console.log(`${metaString} `, metadata.message, ...additional);\n    }\n  }\n  /** Log to the console */\n  logModern(metadata, config, metaString) {\n    const color = this.getColor(metadata, config);\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n      case NgxLoggerLevel.DEBUG:\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n    }\n  }\n  /** Write the content sent to the log function to the console */\n  writeMessage(metadata, config) {\n    const metaString = this.prepareMetaString(metadata, config);\n    this.logFunc(metadata, config, metaString);\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerWriterService.ɵfac = function NGXLoggerWriterService_Factory(t) {\n  return new (t || NGXLoggerWriterService)(i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLoggerWriterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerWriterService,\n  factory: NGXLoggerWriterService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nclass NGXLogger {\n  constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n    this.configEngine = configEngineFactory.provideConfigEngine(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n  get level() {\n    return this.configEngine.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n  get serverLogLevel() {\n    return this.configEngine.serverLogLevel;\n  }\n  trace(message, ...additional) {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n  debug(message, ...additional) {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n  info(message, ...additional) {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n  log(message, ...additional) {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n  warn(message, ...additional) {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n  error(message, ...additional) {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n  fatal(message, ...additional) {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\n  setCustomHttpHeaders(headers) {\n    const config = this.getConfigSnapshot();\n    config.customHttpHeaders = headers;\n    this.updateConfig(config);\n  }\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\n  setCustomParams(params) {\n    const config = this.getConfigSnapshot();\n    config.customHttpParams = params;\n    this.updateConfig(config);\n  }\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\n  setWithCredentialsOptionValue(withCredentials) {\n    const config = this.getConfigSnapshot();\n    config.withCredentials = withCredentials;\n    this.updateConfig(config);\n  }\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   *\r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor\r\n   */\n  registerMonitor(monitor) {\n    this._loggerMonitor = monitor;\n  }\n  /** Set config of logger\r\n   *\r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\n  updateConfig(config) {\n    this.configEngine.updateConfig(config);\n  }\n  partialUpdateConfig(partialConfig) {\n    this.configEngine.partialUpdateConfig(partialConfig);\n  }\n  /** Get config of logger */\n  getConfigSnapshot() {\n    return this.configEngine.getConfig();\n  }\n  /**\r\n   * Flush the serveur queue\r\n   */\n  flushServerQueue() {\n    this.serverService.flushQueue(this.getConfigSnapshot());\n  }\n  _log(level, message, additional = []) {\n    const config = this.configEngine.getConfig();\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\n      // If nothing is to be called we return\n      return;\n    }\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\n      if (logPosition) {\n        metadata.fileName = logPosition.fileName;\n        metadata.lineNumber = logPosition.lineNumber;\n        metadata.columnNumber = logPosition.columnNumber;\n      }\n      if (shouldCallMonitor && this._loggerMonitor) {\n        this._loggerMonitor.onLog(metadata, config);\n      }\n      if (shouldCallWriter) {\n        this.writerService.writeMessage(metadata, config);\n      }\n      if (shouldCallServer) {\n        this.serverService.sendToServer(metadata, config);\n      }\n    });\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nNGXLogger.ɵfac = function NGXLogger_Factory(t) {\n  return new (t || NGXLogger)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */ /** @nocollapse */\nNGXLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLogger,\n  factory: NGXLogger.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLogger, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\nclass CustomNGXLoggerService {\n  constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.logger = logger;\n    this.configEngineFactory = configEngineFactory;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n  }\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n   * @param config\r\n   * @param serverService\r\n   * @param logMonitor\r\n   * @param mapperService\r\n   * @returns\r\n   */\n  create(config, serverService, logMonitor, mapperService) {\n    return this.getNewInstance({\n      config,\n      serverService,\n      logMonitor,\n      mapperService\n    });\n  }\n  /**\r\n   * Get a new instance of NGXLogger\r\n   * @param params list of optional params to use when creating an instance of NGXLogger\r\n   * @returns the new instance of NGXLogger\r\n   */\n  getNewInstance(params) {\n    const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\n    if (params?.partialConfig) {\n      logger.partialUpdateConfig(params.partialConfig);\n    }\n    if (params?.logMonitor) {\n      logger.registerMonitor(params.logMonitor);\n    }\n    return logger;\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nCustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) {\n  return new (t || CustomNGXLoggerService)(i0.ɵɵinject(NGXLogger), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */ /** @nocollapse */\nCustomNGXLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CustomNGXLoggerService,\n  factory: CustomNGXLoggerService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NGXLogger\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\nclass LoggerModule {\n  static forRoot(config, customProvider) {\n    if (!customProvider) {\n      customProvider = {};\n    }\n    // default config provider\n    if (!customProvider.configProvider) {\n      customProvider.configProvider = {\n        provide: TOKEN_LOGGER_CONFIG,\n        useValue: config || {}\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\n      }\n    }\n    // default configEngine provider\n    if (!customProvider.configEngineFactoryProvider) {\n      customProvider.configEngineFactoryProvider = {\n        provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY,\n        useClass: NGXLoggerConfigEngineFactory\n      };\n    } else {\n      // if the user provided its own configEngineFactory, we just make sure the injection token is correct\n      if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\n        throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\n      }\n    }\n    // default metadata provider\n    if (!customProvider.metadataProvider) {\n      customProvider.metadataProvider = {\n        provide: TOKEN_LOGGER_METADATA_SERVICE,\n        useClass: NGXLoggerMetadataService\n      };\n    } else {\n      // if the user provided its own metadataService, we just make sure the injection token is correct\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\n      }\n    }\n    // default rule provider\n    if (!customProvider.ruleProvider) {\n      customProvider.ruleProvider = {\n        provide: TOKEN_LOGGER_RULES_SERVICE,\n        useClass: NGXLoggerRulesService\n      };\n    } else {\n      // if the user provided its own ruleService, we just make sure the injection token is correct\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\n      }\n    }\n    // default mapper provider\n    if (!customProvider.mapperProvider) {\n      customProvider.mapperProvider = {\n        provide: TOKEN_LOGGER_MAPPER_SERVICE,\n        useClass: NGXLoggerMapperService\n      };\n    } else {\n      // if the user provided its own mapperService, we just make sure the injection token is correct\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\n      }\n    }\n    // default writer provider\n    if (!customProvider.writerProvider) {\n      customProvider.writerProvider = {\n        provide: TOKEN_LOGGER_WRITER_SERVICE,\n        useClass: NGXLoggerWriterService\n      };\n    } else {\n      // if the user provided its own writerService, we just make sure the injection token is correct\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n    // default server provider\n    if (!customProvider.serverProvider) {\n      customProvider.serverProvider = {\n        provide: TOKEN_LOGGER_SERVER_SERVICE,\n        useClass: NGXLoggerServerService\n      };\n    } else {\n      // if the user provided its own serverService, we just make sure the injection token is correct\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n    return {\n      ngModule: LoggerModule,\n      providers: [NGXLogger, customProvider.configProvider, customProvider.configEngineFactoryProvider, customProvider.metadataProvider, customProvider.ruleProvider, customProvider.mapperProvider, customProvider.writerProvider, customProvider.serverProvider, CustomNGXLoggerService]\n    };\n  }\n  static forChild() {\n    // todo : this forChild is useless for now because nothing is different from forRoot.\n    // This should be implemented so that user can change the providers in the forChild\n    return {\n      ngModule: LoggerModule\n    };\n  }\n}\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵfac = function LoggerModule_Factory(t) {\n  return new (t || LoggerModule)();\n};\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoggerModule\n});\n/** @nocollapse */ /** @nocollapse */\nLoggerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };","map":{"version":3,"names":["i1","HttpRequest","HttpResponse","HttpHeaders","HttpParams","i0","Injectable","Optional","PLATFORM_ID","Inject","NgModule","of","BehaviorSubject","isObservable","throwError","timer","filter","map","retry","shareReplay","catchError","concatMap","take","vlq","i1$1","isPlatformBrowser","CommonModule","TOKEN_LOGGER_CONFIG","NGXLoggerConfigEngine","constructor","config","_clone","level","serverLogLevel","updateConfig","partialUpdateConfig","partialConfig","Object","keys","forEach","configParamKey","getConfig","object","cloneConfig","key","TOKEN_LOGGER_CONFIG_ENGINE_FACTORY","NGXLoggerConfigEngineFactory","provideConfigEngine","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","firstStackLine","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","position","substring","dataArray","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","decode","sources","distPosition","req","distPositionKey","has","get","console","set","handle","pipe","httpResponse","body","logPosition$","ɵfac","NGXLoggerMapperService_Factory","t","ɵɵinject","HttpBackend","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","decorators","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","computeTimestamp","defaultTimestamp","Date","toISOString","timestampFormat","transform","getMetadata","message","additional","timestamp","NGXLoggerMetadataService_Factory","DatePipe","NGXLoggerMonitor","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","NGXLoggerRulesService_Factory","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","ngZone","serverCallsQueue","flushingQueue","ngOnDestroy","complete","addToQueueTimer","unsubscribe","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","alterHttpRequest","httpRequest","logOnServer","url","logContent","options","defaultRequest","finalRequest","alteredRequest","warn","customiseRequestBody","flushQueue","sendToServerAction","requestBody","secureMetadata","pMetadata","securedMetadata","Array","isArray","m","push","headers","customHttpHeaders","logOnServerAction","params","customHttpParams","responseType","httpResponseType","withCredentials","subscribe","serverCallsOutsideNgZone","runOutsideAngular","sendToServer","serverCallsBatchSize","serverCallsTimer","addLogToQueueAction","_","value","fq","NGXLoggerServerService_Factory","NgZone","TOKEN_LOGGER_WRITER_SERVICE","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","prepareMetaStringFuncs","getTimestampToWrite","getLevelToWrite","getFileDetailsToWrite","getContextToWrite","isIE","navigator","userAgent","match","logFunc","logIE","bind","logModern","disableFileDetails","context","prepareMetaString","metaString","prepareMetaStringFunc","metaItem","trim","getColor","configColorScheme","colorScheme","OFF","WARN","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","NGXLoggerWriterService_Factory","args","NGXLogger","configEngineFactory","metadataService","ruleService","mapperService","writerService","serverService","configEngine","trace","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","flushServerQueue","onLog","NGXLogger_Factory","providedIn","CustomNGXLoggerService","logger","create","logMonitor","getNewInstance","CustomNGXLoggerService_Factory","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineFactoryProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","LoggerModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports"],"sources":["C:/Claro/chronos-angular/node_modules/ngx-logger/fesm2020/ngx-logger.mjs"],"sourcesContent":["import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\r\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\r\n    constructor(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.config.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.config.serverLogLevel;\r\n    }\r\n    updateConfig(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Update the config partially\r\n     * This is useful if you want to update only one parameter of the config\r\n     */\r\n    partialUpdateConfig(partialConfig) {\r\n        // avoid any error if the config is incorrect\r\n        if (!partialConfig) {\r\n            return;\r\n        }\r\n        Object.keys(partialConfig).forEach(configParamKey => {\r\n            this.config[configParamKey] = partialConfig[configParamKey];\r\n        });\r\n    }\r\n    getConfig() {\r\n        return this._clone(this.config);\r\n    }\r\n    // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n    _clone(object) {\r\n        const cloneConfig = { level: null };\r\n        Object.keys(object).forEach((key) => {\r\n            cloneConfig[key] = object[key];\r\n        });\r\n        return cloneConfig;\r\n    }\r\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\r\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\r\n    provideConfigEngine(config) {\r\n        return new NGXLoggerConfigEngine(config);\r\n    }\r\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\r\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n        /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n        this.sourceMapCache = new Map();\r\n        /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n        this.logPositionCache = new Map();\r\n    }\r\n    /**\r\n     * Returns the log position of the caller\r\n     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n     * @param config\r\n     * @param metadata\r\n     * @returns\r\n     */\r\n    getLogPosition(config, metadata) {\r\n        const stackLine = this.getStackLine(config);\r\n        // if we were not able to parse the stackLine, just return an empty Log Position\r\n        if (!stackLine) {\r\n            return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n        }\r\n        const logPosition = this.getLocalPosition(stackLine);\r\n        if (!config.enableSourceMaps) {\r\n            return of(logPosition);\r\n        }\r\n        const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n        return this.getSourceMap(sourceMapLocation, logPosition);\r\n    }\r\n    /**\r\n     * Get the stackline of the original caller\r\n     * @param config\r\n     * @returns null if stackline was not found\r\n     */\r\n    getStackLine(config) {\r\n        const error = new Error();\r\n        try {\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw error;\r\n        }\r\n        catch (e) {\r\n            try {\r\n                // Here are different examples of stacktrace \r\n                // Firefox (last line is the user code, the 4 first are ours):\r\n                // getStackLine@http://localhost:4200/main.js:358:23\r\n                // getCallerDetails@http://localhost:4200/main.js:557:44\r\n                // _log@http://localhost:4200/main.js:830:28\r\n                // debug@http://localhost:4200/main.js:652:14\r\n                // handleLog@http://localhost:4200/main.js:1158:29\r\n                // Chrome and Edge (last line is the user code):\r\n                // Error\r\n                // at Function.getStackLine (ngx-logger.js:329)\r\n                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n                // at NGXLogger._log (ngx-logger.js:801)\r\n                // at NGXLogger.info (ngx-logger.js:631)\r\n                // at AppComponent.handleLog (app.component.ts:38)\r\n                let defaultProxy = 4; // We make 4 functions call before getting here\r\n                const firstStackLine = error.stack.split('\\n')[0];\r\n                if (!firstStackLine.includes('.js:')) {\r\n                    // The stacktrace starts with no function call (example in Chrome or Edge)\r\n                    defaultProxy = defaultProxy + 1;\r\n                }\r\n                return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get position of caller without using sourceMaps\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getLocalPosition(stackLine) {\r\n        // strip base path, then parse filename, line, and column, stackline looks like this :\r\n        // Firefox\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n        // Chrome and Edge\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n        const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n        let positionEndIndex = stackLine.indexOf(')');\r\n        if (positionEndIndex < 0) {\r\n            positionEndIndex = undefined;\r\n        }\r\n        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n        const dataArray = position.split(':');\r\n        if (dataArray.length === 3) {\r\n            return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n        }\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    getTranspileLocation(stackLine) {\r\n        // Example stackLine:\r\n        // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n        let locationStartIndex = stackLine.indexOf('(');\r\n        if (locationStartIndex < 0) {\r\n            locationStartIndex = stackLine.lastIndexOf('@');\r\n            if (locationStartIndex < 0) {\r\n                locationStartIndex = stackLine.lastIndexOf(' ');\r\n            }\r\n        }\r\n        let locationEndIndex = stackLine.indexOf(')');\r\n        if (locationEndIndex < 0) {\r\n            locationEndIndex = undefined;\r\n        }\r\n        return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n    }\r\n    /**\r\n     * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getSourceMapLocation(stackLine) {\r\n        const file = this.getTranspileLocation(stackLine);\r\n        const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n    }\r\n    getMapping(sourceMap, position) {\r\n        // => ';' indicates end of a line\r\n        // => ',' separates mappings in a line\r\n        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n        let sourceFileIndex = 0, // second field\r\n        sourceCodeLine = 0, // third field\r\n        sourceCodeColumn = 0; // fourth field\r\n        const lines = sourceMap.mappings.split(';');\r\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n            // reset column position to 0 after each line\r\n            let generatedCodeColumn = 0;\r\n            // decode sections in line\r\n            const columns = lines[lineIndex].split(',');\r\n            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n                const decodedSection = vlq.decode(columns[columnIndex]);\r\n                if (decodedSection.length >= 4) {\r\n                    // update relative positions\r\n                    generatedCodeColumn += decodedSection[0];\r\n                    sourceFileIndex += decodedSection[1];\r\n                    sourceCodeLine += decodedSection[2];\r\n                    sourceCodeColumn += decodedSection[3];\r\n                }\r\n                // check if matching map\r\n                if (lineIndex === position.lineNumber) {\r\n                    if (generatedCodeColumn === position.columnNumber) {\r\n                        // matching column and line found\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n                    }\r\n                    else if (columnIndex + 1 === columns.length) {\r\n                        // matching column not found, but line is correct\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // failed if reached\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    /**\r\n     * does the http get request to get the source map\r\n     * @param sourceMapLocation\r\n     * @param distPosition\r\n     */\r\n    getSourceMap(sourceMapLocation, distPosition) {\r\n        const req = new HttpRequest('GET', sourceMapLocation);\r\n        const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n        // if the specific log position is already in cache return it\r\n        if (this.logPositionCache.has(distPositionKey)) {\r\n            return this.logPositionCache.get(distPositionKey);\r\n        }\r\n        // otherwise check if the source map is already cached for given source map location\r\n        if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n            if (!this.httpBackend) {\r\n                console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n                this.sourceMapCache.set(sourceMapLocation, of(null));\r\n            }\r\n            else {\r\n                // obtain the source map if not cached\r\n                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));\r\n            }\r\n        }\r\n        // at this point the source map is cached, use it to get specific log position mapping\r\n        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => {\r\n            // sourceMap can be null if HttpBackend is not provided for example\r\n            if (!sourceMap) {\r\n                return distPosition;\r\n            }\r\n            // map generated position to source position\r\n            return this.getMapping(sourceMap, distPosition);\r\n        }), catchError(() => of(distPosition)), shareReplay(1));\r\n        // store specific log position in cache for given dest position and return it\r\n        this.logPositionCache.set(distPositionKey, logPosition$);\r\n        return logPosition$;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\r\n    constructor(datePipe) {\r\n        this.datePipe = datePipe;\r\n    }\r\n    computeTimestamp(config) {\r\n        const defaultTimestamp = () => new Date().toISOString();\r\n        if (config.timestampFormat) {\r\n            if (!this.datePipe) {\r\n                console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\r\n                return defaultTimestamp();\r\n            }\r\n            else {\r\n                return this.datePipe.transform(new Date(), config.timestampFormat);\r\n            }\r\n        }\r\n        return defaultTimestamp();\r\n    }\r\n    getMetadata(level, config, message, additional) {\r\n        const metadata = {\r\n            level: level,\r\n            additional: additional,\r\n        };\r\n        // The user can send a function\r\n        // This is useful in order to compute string concatenation only when the log will actually be written\r\n        if (message && typeof message === 'function') {\r\n            metadata.message = message();\r\n        }\r\n        else {\r\n            metadata.message = message;\r\n        }\r\n        metadata.timestamp = this.computeTimestamp(config);\r\n        return metadata;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, deps: [{ token: i1$1.DatePipe, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1$1.DatePipe, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nclass NGXLoggerMonitor {\r\n}\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\r\n    shouldCallWriter(level, config, message, additional) {\r\n        return !config.disableConsoleLogging && level >= config.level;\r\n    }\r\n    shouldCallServer(level, config, message, additional) {\r\n        return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    }\r\n    shouldCallMonitor(level, config, message, additional) {\r\n        // The default behavior is to call the monitor only if the writer or the server is called\r\n        return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Injection token of logger server service\r\n */\r\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\r\n    constructor(httpBackend, ngZone) {\r\n        this.httpBackend = httpBackend;\r\n        this.ngZone = ngZone;\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue = new BehaviorSubject(false);\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.flushingQueue) {\r\n            this.flushingQueue.complete();\r\n            this.flushingQueue = null;\r\n        }\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Transforms an error object into a readable string (taking only the stack)\r\n     * This is needed because JSON.stringify would return \"{}\"\r\n     * @param err the error object\r\n     * @returns The stack of the error\r\n     */\r\n    secureErrorObject(err) {\r\n        return err?.stack;\r\n    }\r\n    /**\r\n     * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n     * Basically it just replaces unstringifiable object to a string mentioning an error\r\n     * @param additional The additional data to be sent\r\n     * @returns The additional data secured\r\n     */\r\n    secureAdditionalParameters(additional) {\r\n        if (additional === null || additional === undefined) {\r\n            return null;\r\n        }\r\n        return additional.map((next, idx) => {\r\n            try {\r\n                if (next instanceof Error) {\r\n                    return this.secureErrorObject(next);\r\n                }\r\n                // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n                if (typeof next === 'object') {\r\n                    JSON.stringify(next);\r\n                }\r\n                return next;\r\n            }\r\n            catch (e) {\r\n                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Transforms the message so that it can be sent to the server\r\n     * @param message the message to be sent\r\n     * @returns the message secured\r\n     */\r\n    secureMessage(message) {\r\n        try {\r\n            if (message instanceof Error) {\r\n                return this.secureErrorObject(message);\r\n            }\r\n            if (typeof message !== 'string') {\r\n                message = JSON.stringify(message, null, 2);\r\n            }\r\n        }\r\n        catch (e) {\r\n            message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Edits HttpRequest object before sending request to server\r\n     * @param httpRequest default request object\r\n     * @returns altered httprequest\r\n     */\r\n    alterHttpRequest(httpRequest) {\r\n        return httpRequest;\r\n    }\r\n    /**\r\n     * Sends request to server\r\n     * @param url\r\n     * @param logContent\r\n     * @param options\r\n     * @returns\r\n     */\r\n    logOnServer(url, logContent, options) {\r\n        if (!this.httpBackend) {\r\n            console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n            return of(null);\r\n        }\r\n        // HttpBackend skips all HttpInterceptors\r\n        // They may log errors using this service causing circular calls\r\n        let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\r\n        let finalRequest = of(defaultRequest);\r\n        const alteredRequest = this.alterHttpRequest(defaultRequest);\r\n        if (isObservable(alteredRequest)) {\r\n            finalRequest = alteredRequest;\r\n        }\r\n        else if (alteredRequest) {\r\n            finalRequest = of(alteredRequest);\r\n        }\r\n        else {\r\n            console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\r\n        }\r\n        return finalRequest.pipe(concatMap(req => {\r\n            if (!req) {\r\n                console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\r\n                return this.httpBackend.handle(defaultRequest);\r\n            }\r\n            return this.httpBackend.handle(req);\r\n        }), filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));\r\n    }\r\n    /**\r\n     * Customise the data sent to the API\r\n     * @param metadata the data provided by NGXLogger\r\n     * @returns the data that will be sent to the API in the body\r\n     */\r\n    customiseRequestBody(metadata) {\r\n        // In our API the body is not customised\r\n        return metadata;\r\n    }\r\n    /**\r\n     * Flush the queue of the logger\r\n     * @param config\r\n     */\r\n    flushQueue(config) {\r\n        this.flushingQueue.next(true);\r\n        // If a timer was set, we cancel it because the queue is flushed\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n        if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\r\n            this.sendToServerAction(this.serverCallsQueue, config);\r\n        }\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue.next(false);\r\n    }\r\n    sendToServerAction(metadata, config) {\r\n        let requestBody;\r\n        const secureMetadata = (pMetadata) => {\r\n            // Copying metadata locally because we don't want to change the object for the caller\r\n            const securedMetadata = { ...pMetadata };\r\n            securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\r\n            securedMetadata.message = this.secureMessage(securedMetadata.message);\r\n            return securedMetadata;\r\n        };\r\n        if (Array.isArray(metadata)) {\r\n            requestBody = [];\r\n            metadata.forEach(m => {\r\n                requestBody.push(secureMetadata(m));\r\n            });\r\n        }\r\n        else {\r\n            requestBody = secureMetadata(metadata);\r\n        }\r\n        // Allow users to customise the data sent to the API\r\n        requestBody = this.customiseRequestBody(requestBody);\r\n        const headers = config.customHttpHeaders || new HttpHeaders();\r\n        if (!headers.has('Content-Type')) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n        const logOnServerAction = () => {\r\n            this.logOnServer(config.serverLoggingUrl, requestBody, {\r\n                headers,\r\n                params: config.customHttpParams || new HttpParams(),\r\n                responseType: config.httpResponseType || 'json',\r\n                withCredentials: config.withCredentials || false,\r\n            }).pipe(catchError(err => {\r\n                // Do not use NGXLogger here because this could cause an infinite loop \r\n                console.error('NGXLogger: Failed to log on server', err);\r\n                return throwError(err);\r\n            })).subscribe();\r\n        };\r\n        if (config.serverCallsOutsideNgZone === true) {\r\n            if (!this.ngZone) {\r\n                console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\r\n                return;\r\n            }\r\n            this.ngZone.runOutsideAngular(logOnServerAction);\r\n        }\r\n        else {\r\n            logOnServerAction();\r\n        }\r\n    }\r\n    /**\r\n     * Sends the content to be logged to the server according to the config\r\n     * @param metadata\r\n     * @param config\r\n     */\r\n    sendToServer(metadata, config) {\r\n        // If there is no batch mode in the config, we send the log call straight to the server as usual\r\n        if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) &&\r\n            (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\r\n            this.sendToServerAction(metadata, config);\r\n            return;\r\n        }\r\n        const addLogToQueueAction = () => {\r\n            this.serverCallsQueue.push({ ...metadata });\r\n            // Flush queue when size is reached\r\n            if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\r\n                this.flushQueue(config);\r\n            }\r\n            // Call timer only if it is in the config and timer is not already running\r\n            if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\r\n                this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\r\n                    this.flushQueue(config);\r\n                });\r\n            }\r\n        };\r\n        // If queue is being flushed, we need to wait for it to finish before adding other calls\r\n        if (this.flushingQueue.value === true) {\r\n            this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\r\n                addLogToQueueAction();\r\n            });\r\n        }\r\n        else {\r\n            addLogToQueueAction();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }, { token: i0.NgZone, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }, { type: i0.NgZone, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger writer service\r\n */\r\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\n\nvar NgxLoggerLevel;\r\n(function (NgxLoggerLevel) {\r\n    NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\r\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = [\r\n    'purple',\r\n    'teal',\r\n    'gray',\r\n    'gray',\r\n    'red',\r\n    'red',\r\n    'red'\r\n];\n\nclass NGXLoggerWriterService {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n        /** List of functions called when preparing meta string */\r\n        this.prepareMetaStringFuncs = [\r\n            this.getTimestampToWrite,\r\n            this.getLevelToWrite,\r\n            this.getFileDetailsToWrite,\r\n            this.getContextToWrite,\r\n        ];\r\n        this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n        this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n    }\r\n    getTimestampToWrite(metadata, config) {\r\n        return metadata.timestamp;\r\n    }\r\n    getLevelToWrite(metadata, config) {\r\n        return NgxLoggerLevel[metadata.level];\r\n    }\r\n    getFileDetailsToWrite(metadata, config) {\r\n        return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n    }\r\n    getContextToWrite(metadata, config) {\r\n        return config.context ? `{${config.context}}` : '';\r\n    }\r\n    /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n    prepareMetaString(metadata, config) {\r\n        let metaString = '';\r\n        this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\r\n            const metaItem = prepareMetaStringFunc(metadata, config);\r\n            if (metaItem) {\r\n                metaString = metaString + ' ' + metaItem;\r\n            }\r\n        });\r\n        return metaString.trim();\r\n    }\r\n    /** Get the color to use when writing to console */\r\n    getColor(metadata, config) {\r\n        const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\r\n        // this is needed to avoid a build error\r\n        if (metadata.level === NgxLoggerLevel.OFF) {\r\n            return undefined;\r\n        }\r\n        return configColorScheme[metadata.level];\r\n    }\r\n    /** Log to the console specifically for IE */\r\n    logIE(metadata, config, metaString) {\r\n        // Coloring doesn't work in IE\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`${metaString} `, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Log to the console */\r\n    logModern(metadata, config, metaString) {\r\n        const color = this.getColor(metadata, config);\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n            // the console.trace statement\r\n            // case NgxLoggerLevel.TRACE:\r\n            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n            //   break;\r\n            case NgxLoggerLevel.DEBUG:\r\n                console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Write the content sent to the log function to the console */\r\n    writeMessage(metadata, config) {\r\n        const metaString = this.prepareMetaString(metadata, config);\r\n        this.logFunc(metadata, config, metaString);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass NGXLogger {\r\n    constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n        this.configEngine = configEngineFactory.provideConfigEngine(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.configEngine.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.configEngine.serverLogLevel;\r\n    }\r\n    trace(message, ...additional) {\r\n        this._log(NgxLoggerLevel.TRACE, message, additional);\r\n    }\r\n    debug(message, ...additional) {\r\n        this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n    }\r\n    info(message, ...additional) {\r\n        this._log(NgxLoggerLevel.INFO, message, additional);\r\n    }\r\n    log(message, ...additional) {\r\n        this._log(NgxLoggerLevel.LOG, message, additional);\r\n    }\r\n    warn(message, ...additional) {\r\n        this._log(NgxLoggerLevel.WARN, message, additional);\r\n    }\r\n    error(message, ...additional) {\r\n        this._log(NgxLoggerLevel.ERROR, message, additional);\r\n    }\r\n    fatal(message, ...additional) {\r\n        this._log(NgxLoggerLevel.FATAL, message, additional);\r\n    }\r\n    /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomHttpHeaders(headers) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpHeaders = headers;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomParams(params) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpParams = params;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n    setWithCredentialsOptionValue(withCredentials) {\r\n        const config = this.getConfigSnapshot();\r\n        config.withCredentials = withCredentials;\r\n        this.updateConfig(config);\r\n    }\r\n    /**\r\n     * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n     *\r\n     * There is only one monitor, registering one will overwrite the last one if there was one\r\n     * @param monitor\r\n     */\r\n    registerMonitor(monitor) {\r\n        this._loggerMonitor = monitor;\r\n    }\r\n    /** Set config of logger\r\n     *\r\n     * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n     */\r\n    updateConfig(config) {\r\n        this.configEngine.updateConfig(config);\r\n    }\r\n    partialUpdateConfig(partialConfig) {\r\n        this.configEngine.partialUpdateConfig(partialConfig);\r\n    }\r\n    /** Get config of logger */\r\n    getConfigSnapshot() {\r\n        return this.configEngine.getConfig();\r\n    }\r\n    /**\r\n     * Flush the serveur queue\r\n     */\r\n    flushServerQueue() {\r\n        this.serverService.flushQueue(this.getConfigSnapshot());\r\n    }\r\n    _log(level, message, additional = []) {\r\n        const config = this.configEngine.getConfig();\r\n        const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n        const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n        const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n        if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n            // If nothing is to be called we return\r\n            return;\r\n        }\r\n        const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n        this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n            if (logPosition) {\r\n                metadata.fileName = logPosition.fileName;\r\n                metadata.lineNumber = logPosition.lineNumber;\r\n                metadata.columnNumber = logPosition.columnNumber;\r\n            }\r\n            if (shouldCallMonitor && this._loggerMonitor) {\r\n                this._loggerMonitor.onLog(metadata, config);\r\n            }\r\n            if (shouldCallWriter) {\r\n                this.writerService.writeMessage(metadata, config);\r\n            }\r\n            if (shouldCallServer) {\r\n                this.serverService.sendToServer(metadata, config);\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, deps: [{ token: TOKEN_LOGGER_CONFIG }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\r\nclass CustomNGXLoggerService {\r\n    constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.logger = logger;\r\n        this.configEngineFactory = configEngineFactory;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n    }\r\n    /**\r\n     * Create an instance of a logger\r\n     * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n     * @param config\r\n     * @param serverService\r\n     * @param logMonitor\r\n     * @param mapperService\r\n     * @returns\r\n     */\r\n    create(config, serverService, logMonitor, mapperService) {\r\n        return this.getNewInstance({\r\n            config,\r\n            serverService,\r\n            logMonitor,\r\n            mapperService\r\n        });\r\n    }\r\n    /**\r\n     * Get a new instance of NGXLogger\r\n     * @param params list of optional params to use when creating an instance of NGXLogger\r\n     * @returns the new instance of NGXLogger\r\n     */\r\n    getNewInstance(params) {\r\n        const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\r\n        if (params?.partialConfig) {\r\n            logger.partialUpdateConfig(params.partialConfig);\r\n        }\r\n        if (params?.logMonitor) {\r\n            logger.registerMonitor(params.logMonitor);\r\n        }\r\n        return logger;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, deps: [{ token: NGXLogger }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: NGXLogger }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\nclass LoggerModule {\r\n    static forRoot(config, customProvider) {\r\n        if (!customProvider) {\r\n            customProvider = {};\r\n        }\r\n        // default config provider\r\n        if (!customProvider.configProvider) {\r\n            customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n                throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n            }\r\n        }\r\n        // default configEngine provider\r\n        if (!customProvider.configEngineFactoryProvider) {\r\n            customProvider.configEngineFactoryProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactory };\r\n        }\r\n        else {\r\n            // if the user provided its own configEngineFactory, we just make sure the injection token is correct\r\n            if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\r\n                throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\r\n            }\r\n        }\r\n        // default metadata provider\r\n        if (!customProvider.metadataProvider) {\r\n            customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n        }\r\n        else {\r\n            // if the user provided its own metadataService, we just make sure the injection token is correct\r\n            if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n                throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n            }\r\n        }\r\n        // default rule provider\r\n        if (!customProvider.ruleProvider) {\r\n            customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n        }\r\n        else {\r\n            // if the user provided its own ruleService, we just make sure the injection token is correct\r\n            if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n                throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n            }\r\n        }\r\n        // default mapper provider\r\n        if (!customProvider.mapperProvider) {\r\n            customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n        }\r\n        else {\r\n            // if the user provided its own mapperService, we just make sure the injection token is correct\r\n            if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n                throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n            }\r\n        }\r\n        // default writer provider\r\n        if (!customProvider.writerProvider) {\r\n            customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n        }\r\n        else {\r\n            // if the user provided its own writerService, we just make sure the injection token is correct\r\n            if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n                throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        // default server provider\r\n        if (!customProvider.serverProvider) {\r\n            customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n        }\r\n        else {\r\n            // if the user provided its own serverService, we just make sure the injection token is correct\r\n            if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n                throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        return {\r\n            ngModule: LoggerModule,\r\n            providers: [\r\n                NGXLogger,\r\n                customProvider.configProvider,\r\n                customProvider.configEngineFactoryProvider,\r\n                customProvider.metadataProvider,\r\n                customProvider.ruleProvider,\r\n                customProvider.mapperProvider,\r\n                customProvider.writerProvider,\r\n                customProvider.serverProvider,\r\n                CustomNGXLoggerService,\r\n            ]\r\n        };\r\n    }\r\n    static forChild() {\r\n        // todo : this forChild is useless for now because nothing is different from forRoot.\r\n        // This should be implemented so that user can change the providers in the forChild\r\n        return {\r\n            ngModule: LoggerModule,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [CommonModule] });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [\r\n                        CommonModule\r\n                    ],\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}