{"ast":null,"code":"const debug = require('debug')('log4js:categories');\nconst configuration = require('./configuration');\nconst levels = require('./levels');\nconst appenders = require('./appenders');\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.slice(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = {\n      inherit: true,\n      appenders: []\n    };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach(ap => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\nconfiguration.addListener(config => {\n  configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property \"categories\" of type object.');\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(config, configuration.not(categoryNames.length), 'must define at least one category.');\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(config, [configuration.not(category.appenders), configuration.not(category.level)], `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`);\n    configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category \"${name}\" is not valid (appenders must be an array of appender names)`);\n    configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category \"${name}\" is not valid (appenders must contain at least one appender name)`);\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(config, typeof category.enableCallStack !== 'boolean', `category \"${name}\" is not valid (enableCallStack must be boolean type)`);\n    }\n    category.appenders.forEach(appender => {\n      configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`);\n    });\n    configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category \"${name}\" is not valid (level \"${category.level}\" not recognised;` + ` valid levels are ${levels.levels.join(', ')})`);\n  });\n  configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a \"default\" category.');\n});\nconst setup = config => {\n  categories.clear();\n  if (!config) {\n    return;\n  }\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(name => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach(appender => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false\n      });\n    });\n  });\n};\nconst init = () => {\n  setup();\n};\ninit();\nconfiguration.addListener(setup);\nconst configForCategory = category => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n  let sourceCategoryConfig;\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, cloning from parents`);\n    sourceCategoryConfig = {\n      ...configForCategory(category.slice(0, category.lastIndexOf('.')))\n    };\n  } else {\n    if (!categories.has('default')) {\n      setup({\n        categories: {\n          default: {\n            appenders: ['out'],\n            level: 'OFF'\n          }\n        }\n      });\n    }\n    debug('configForCategory: cloning default category');\n    sourceCategoryConfig = {\n      ...categories.get('default')\n    };\n  }\n  categories.set(category, sourceCategoryConfig);\n  return sourceCategoryConfig;\n};\nconst appendersForCategory = category => configForCategory(category).appenders;\nconst getLevelForCategory = category => configForCategory(category).level;\nconst setLevelForCategory = (category, level) => {\n  configForCategory(category).level = level;\n};\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\nmodule.exports = categories;\nmodule.exports = Object.assign(module.exports, {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n  init\n});","map":{"version":3,"names":["debug","require","configuration","levels","appenders","categories","Map","inheritFromParent","config","category","categoryName","inherit","lastDotIndex","lastIndexOf","parentCategoryName","slice","parentCategory","length","level","forEach","ap","includes","push","parent","addCategoryInheritance","categoryNames","Object","keys","name","addPreProcessingListener","addListener","throwExceptionIf","not","anObject","Array","isArray","prototype","hasOwnProperty","call","enableCallStack","appender","get","getLevel","join","default","setup","clear","categoryAppenders","set","init","configForCategory","has","sourceCategoryConfig","indexOf","appendersForCategory","getLevelForCategory","setLevelForCategory","getEnableCallStackForCategory","setEnableCallStackForCategory","useCallStack","module","exports","assign"],"sources":["C:/Claro/chronos-angular/node_modules/log4js/lib/categories.js"],"sourcesContent":["const debug = require('debug')('log4js:categories');\nconst configuration = require('./configuration');\nconst levels = require('./levels');\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.slice(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = { inherit: true, appenders: [] };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (\n    !config.categories[parentCategoryName] &&\n    parentCategory.appenders &&\n    parentCategory.appenders.length &&\n    parentCategory.level\n  ) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach((ap) => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener((config) =>\n  addCategoryInheritance(config)\n);\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.categories)),\n    'must have a property \"categories\" of type object.'\n  );\n\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(categoryNames.length),\n    'must define at least one category.'\n  );\n\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(\n      config,\n      [\n        configuration.not(category.appenders),\n        configuration.not(category.level),\n      ],\n      `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(Array.isArray(category.appenders)),\n      `category \"${name}\" is not valid (appenders must be an array of appender names)`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(category.appenders.length),\n      `category \"${name}\" is not valid (appenders must contain at least one appender name)`\n    );\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(\n        config,\n        typeof category.enableCallStack !== 'boolean',\n        `category \"${name}\" is not valid (enableCallStack must be boolean type)`\n      );\n    }\n\n    category.appenders.forEach((appender) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(appenders.get(appender)),\n        `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`\n      );\n    });\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(levels.getLevel(category.level)),\n      `category \"${name}\" is not valid (level \"${category.level}\" not recognised;` +\n        ` valid levels are ${levels.levels.join(', ')})`\n    );\n  });\n\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(config.categories.default),\n    'must define a \"default\" category.'\n  );\n});\n\nconst setup = (config) => {\n  categories.clear();\n  if (!config) {\n    return;\n  }\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach((appender) => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false,\n      });\n    });\n  });\n};\n\nconst init = () => {\n  setup();\n};\ninit();\n\nconfiguration.addListener(setup);\n\nconst configForCategory = (category) => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n\n  let sourceCategoryConfig;\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, cloning from parents`);\n    sourceCategoryConfig = {\n      ...configForCategory(category.slice(0, category.lastIndexOf('.'))),\n    };\n  } else {\n    if (!categories.has('default')) {\n      setup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });\n    }\n    debug('configForCategory: cloning default category');\n    sourceCategoryConfig = { ...categories.get('default') };\n  }\n  categories.set(category, sourceCategoryConfig);\n  return sourceCategoryConfig;\n};\n\nconst appendersForCategory = (category) =>\n  configForCategory(category).appenders;\n\nconst getLevelForCategory = (category) => configForCategory(category).level;\nconst setLevelForCategory = (category, level) => {\n  configForCategory(category).level = level;\n};\n\nconst getEnableCallStackForCategory = (category) =>\n  configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = categories;\nmodule.exports = Object.assign(module.exports, {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n  init,\n});\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,mBAAmB,CAAC;AACnD,MAAMC,aAAa,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAClC,MAAMG,SAAS,GAAGH,OAAO,CAAC,aAAa,CAAC;AAExC,MAAMI,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,YAAY,EAAE;EACzD,IAAID,QAAQ,CAACE,OAAO,KAAK,KAAK,EAAE;EAChC,MAAMC,YAAY,GAAGF,YAAY,CAACG,WAAW,CAAC,GAAG,CAAC;EAClD,IAAID,YAAY,GAAG,CAAC,EAAE,OAAO,CAAC;EAC9B,MAAME,kBAAkB,GAAGJ,YAAY,CAACK,KAAK,CAAC,CAAC,EAAEH,YAAY,CAAC;EAC9D,IAAII,cAAc,GAAGR,MAAM,CAACH,UAAU,CAACS,kBAAkB,CAAC;EAE1D,IAAI,CAACE,cAAc,EAAE;IACnB;IACAA,cAAc,GAAG;MAAEL,OAAO,EAAE,IAAI;MAAEP,SAAS,EAAE;IAAG,CAAC;EACnD;;EAEA;EACAG,iBAAiB,CAACC,MAAM,EAAEQ,cAAc,EAAEF,kBAAkB,CAAC;;EAE7D;EACA;EACA,IACE,CAACN,MAAM,CAACH,UAAU,CAACS,kBAAkB,CAAC,IACtCE,cAAc,CAACZ,SAAS,IACxBY,cAAc,CAACZ,SAAS,CAACa,MAAM,IAC/BD,cAAc,CAACE,KAAK,EACpB;IACAV,MAAM,CAACH,UAAU,CAACS,kBAAkB,CAAC,GAAGE,cAAc;EACxD;EAEAP,QAAQ,CAACL,SAAS,GAAGK,QAAQ,CAACL,SAAS,IAAI,EAAE;EAC7CK,QAAQ,CAACS,KAAK,GAAGT,QAAQ,CAACS,KAAK,IAAIF,cAAc,CAACE,KAAK;;EAEvD;EACAF,cAAc,CAACZ,SAAS,CAACe,OAAO,CAAEC,EAAE,IAAK;IACvC,IAAI,CAACX,QAAQ,CAACL,SAAS,CAACiB,QAAQ,CAACD,EAAE,CAAC,EAAE;MACpCX,QAAQ,CAACL,SAAS,CAACkB,IAAI,CAACF,EAAE,CAAC;IAC7B;EACF,CAAC,CAAC;EACFX,QAAQ,CAACc,MAAM,GAAGP,cAAc;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,sBAAsBA,CAAChB,MAAM,EAAE;EACtC,IAAI,CAACA,MAAM,CAACH,UAAU,EAAE;EACxB,MAAMoB,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACnB,MAAM,CAACH,UAAU,CAAC;EACpDoB,aAAa,CAACN,OAAO,CAAES,IAAI,IAAK;IAC9B,MAAMnB,QAAQ,GAAGD,MAAM,CAACH,UAAU,CAACuB,IAAI,CAAC;IACxC;IACArB,iBAAiB,CAACC,MAAM,EAAEC,QAAQ,EAAEmB,IAAI,CAAC;EAC3C,CAAC,CAAC;AACJ;AAEA1B,aAAa,CAAC2B,wBAAwB,CAAErB,MAAM,IAC5CgB,sBAAsB,CAAChB,MAAM,CAC/B,CAAC;AAEDN,aAAa,CAAC4B,WAAW,CAAEtB,MAAM,IAAK;EACpCN,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAAC9B,aAAa,CAAC+B,QAAQ,CAACzB,MAAM,CAACH,UAAU,CAAC,CAAC,EAC5D,mDACF,CAAC;EAED,MAAMoB,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACnB,MAAM,CAACH,UAAU,CAAC;EACpDH,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAACP,aAAa,CAACR,MAAM,CAAC,EACvC,oCACF,CAAC;EAEDQ,aAAa,CAACN,OAAO,CAAES,IAAI,IAAK;IAC9B,MAAMnB,QAAQ,GAAGD,MAAM,CAACH,UAAU,CAACuB,IAAI,CAAC;IACxC1B,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACN,CACEN,aAAa,CAAC8B,GAAG,CAACvB,QAAQ,CAACL,SAAS,CAAC,EACrCF,aAAa,CAAC8B,GAAG,CAACvB,QAAQ,CAACS,KAAK,CAAC,CAClC,EACA,aAAYU,IAAK,4EACpB,CAAC;IAED1B,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAACE,KAAK,CAACC,OAAO,CAAC1B,QAAQ,CAACL,SAAS,CAAC,CAAC,EACnD,aAAYwB,IAAK,+DACpB,CAAC;IAED1B,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAACvB,QAAQ,CAACL,SAAS,CAACa,MAAM,CAAC,EAC3C,aAAYW,IAAK,oEACpB,CAAC;IAED,IAAIF,MAAM,CAACU,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC7B,QAAQ,EAAE,iBAAiB,CAAC,EAAE;MACrEP,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACN,OAAOC,QAAQ,CAAC8B,eAAe,KAAK,SAAS,EAC5C,aAAYX,IAAK,uDACpB,CAAC;IACH;IAEAnB,QAAQ,CAACL,SAAS,CAACe,OAAO,CAAEqB,QAAQ,IAAK;MACvCtC,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAAC5B,SAAS,CAACqC,GAAG,CAACD,QAAQ,CAAC,CAAC,EACzC,aAAYZ,IAAK,6BAA4BY,QAAS,mBACzD,CAAC;IACH,CAAC,CAAC;IAEFtC,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAAC7B,MAAM,CAACuC,QAAQ,CAACjC,QAAQ,CAACS,KAAK,CAAC,CAAC,EACjD,aAAYU,IAAK,0BAAyBnB,QAAQ,CAACS,KAAM,mBAAkB,GACzE,qBAAoBf,MAAM,CAACA,MAAM,CAACwC,IAAI,CAAC,IAAI,CAAE,GAClD,CAAC;EACH,CAAC,CAAC;EAEFzC,aAAa,CAAC6B,gBAAgB,CAC5BvB,MAAM,EACNN,aAAa,CAAC8B,GAAG,CAACxB,MAAM,CAACH,UAAU,CAACuC,OAAO,CAAC,EAC5C,mCACF,CAAC;AACH,CAAC,CAAC;AAEF,MAAMC,KAAK,GAAIrC,MAAM,IAAK;EACxBH,UAAU,CAACyC,KAAK,CAAC,CAAC;EAClB,IAAI,CAACtC,MAAM,EAAE;IACX;EACF;EAEA,MAAMiB,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACnB,MAAM,CAACH,UAAU,CAAC;EACpDoB,aAAa,CAACN,OAAO,CAAES,IAAI,IAAK;IAC9B,MAAMnB,QAAQ,GAAGD,MAAM,CAACH,UAAU,CAACuB,IAAI,CAAC;IACxC,MAAMmB,iBAAiB,GAAG,EAAE;IAC5BtC,QAAQ,CAACL,SAAS,CAACe,OAAO,CAAEqB,QAAQ,IAAK;MACvCO,iBAAiB,CAACzB,IAAI,CAAClB,SAAS,CAACqC,GAAG,CAACD,QAAQ,CAAC,CAAC;MAC/CxC,KAAK,CAAE,qBAAoB4B,IAAK,EAAC,CAAC;MAClCvB,UAAU,CAAC2C,GAAG,CAACpB,IAAI,EAAE;QACnBxB,SAAS,EAAE2C,iBAAiB;QAC5B7B,KAAK,EAAEf,MAAM,CAACuC,QAAQ,CAACjC,QAAQ,CAACS,KAAK,CAAC;QACtCqB,eAAe,EAAE9B,QAAQ,CAAC8B,eAAe,IAAI;MAC/C,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AAED,MAAMU,IAAI,GAAGA,CAAA,KAAM;EACjBJ,KAAK,CAAC,CAAC;AACT,CAAC;AACDI,IAAI,CAAC,CAAC;AAEN/C,aAAa,CAAC4B,WAAW,CAACe,KAAK,CAAC;AAEhC,MAAMK,iBAAiB,GAAIzC,QAAQ,IAAK;EACtCT,KAAK,CAAE,+CAA8CS,QAAS,EAAC,CAAC;EAChE,IAAIJ,UAAU,CAAC8C,GAAG,CAAC1C,QAAQ,CAAC,EAAE;IAC5BT,KAAK,CAAE,sBAAqBS,QAAS,iCAAgC,CAAC;IACtE,OAAOJ,UAAU,CAACoC,GAAG,CAAChC,QAAQ,CAAC;EACjC;EAEA,IAAI2C,oBAAoB;EACxB,IAAI3C,QAAQ,CAAC4C,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IAC7BrD,KAAK,CAAE,sBAAqBS,QAAS,sCAAqC,CAAC;IAC3E2C,oBAAoB,GAAG;MACrB,GAAGF,iBAAiB,CAACzC,QAAQ,CAACM,KAAK,CAAC,CAAC,EAAEN,QAAQ,CAACI,WAAW,CAAC,GAAG,CAAC,CAAC;IACnE,CAAC;EACH,CAAC,MAAM;IACL,IAAI,CAACR,UAAU,CAAC8C,GAAG,CAAC,SAAS,CAAC,EAAE;MAC9BN,KAAK,CAAC;QAAExC,UAAU,EAAE;UAAEuC,OAAO,EAAE;YAAExC,SAAS,EAAE,CAAC,KAAK,CAAC;YAAEc,KAAK,EAAE;UAAM;QAAE;MAAE,CAAC,CAAC;IAC1E;IACAlB,KAAK,CAAC,6CAA6C,CAAC;IACpDoD,oBAAoB,GAAG;MAAE,GAAG/C,UAAU,CAACoC,GAAG,CAAC,SAAS;IAAE,CAAC;EACzD;EACApC,UAAU,CAAC2C,GAAG,CAACvC,QAAQ,EAAE2C,oBAAoB,CAAC;EAC9C,OAAOA,oBAAoB;AAC7B,CAAC;AAED,MAAME,oBAAoB,GAAI7C,QAAQ,IACpCyC,iBAAiB,CAACzC,QAAQ,CAAC,CAACL,SAAS;AAEvC,MAAMmD,mBAAmB,GAAI9C,QAAQ,IAAKyC,iBAAiB,CAACzC,QAAQ,CAAC,CAACS,KAAK;AAC3E,MAAMsC,mBAAmB,GAAGA,CAAC/C,QAAQ,EAAES,KAAK,KAAK;EAC/CgC,iBAAiB,CAACzC,QAAQ,CAAC,CAACS,KAAK,GAAGA,KAAK;AAC3C,CAAC;AAED,MAAMuC,6BAA6B,GAAIhD,QAAQ,IAC7CyC,iBAAiB,CAACzC,QAAQ,CAAC,CAAC8B,eAAe,KAAK,IAAI;AACtD,MAAMmB,6BAA6B,GAAGA,CAACjD,QAAQ,EAAEkD,YAAY,KAAK;EAChET,iBAAiB,CAACzC,QAAQ,CAAC,CAAC8B,eAAe,GAAGoB,YAAY;AAC5D,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAGxD,UAAU;AAC3BuD,MAAM,CAACC,OAAO,GAAGnC,MAAM,CAACoC,MAAM,CAACF,MAAM,CAACC,OAAO,EAAE;EAC7CP,oBAAoB;EACpBC,mBAAmB;EACnBC,mBAAmB;EACnBC,6BAA6B;EAC7BC,6BAA6B;EAC7BT;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}