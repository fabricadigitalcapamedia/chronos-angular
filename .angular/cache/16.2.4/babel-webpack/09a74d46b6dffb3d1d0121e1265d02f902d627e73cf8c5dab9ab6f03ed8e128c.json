{"ast":null,"code":"/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\n\nconst debug = require('debug')('log4js:logger');\nconst LoggingEvent = require('./LoggingEvent');\nconst levels = require('./levels');\nconst clustering = require('./clustering');\nconst categories = require('./categories');\nconst configuration = require('./configuration');\nconst stackReg = /^(?:\\s*)at (?:(.+) \\()?(?:([^(]+?):(\\d+):(\\d+))\\)?$/;\n/**\n * The top entry is the Error\n */\nconst baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\nconst defaultErrorCallStackSkip = 3;\n\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\nfunction defaultParseCallStack(data, skipIdx = defaultErrorCallStackSkip + baseCallStackSkip) {\n  try {\n    const stacklines = data.stack.split('\\n').slice(skipIdx);\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n    const lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n    if (lineMatch && lineMatch.length === 5) {\n      // extract class, function and alias names\n      let className = '';\n      let functionName = '';\n      let functionAlias = '';\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        [functionName, functionAlias] = lineMatch[1].replace(/[[\\]]/g, '').split(' as ');\n        functionAlias = functionAlias || '';\n        if (functionName.includes('.')) [className, functionName] = functionName.split('.');\n      }\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className,\n        functionName,\n        functionAlias,\n        callerName: lineMatch[1] || ''\n      };\n      // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n    this.category = name;\n    this.context = {};\n    /** @private */\n    this.callStackSkipIndex = 0;\n    /** @private */\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n  get level() {\n    return levels.getLevel(categories.getLevelForCategory(this.category), levels.OFF);\n  }\n  set level(level) {\n    categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));\n  }\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n  get callStackLinesToSkip() {\n    return this.callStackSkipIndex;\n  }\n  set callStackLinesToSkip(number) {\n    if (typeof number !== 'number') {\n      throw new TypeError('Must be a number');\n    }\n    if (number < 0) {\n      throw new RangeError('Must be >= 0');\n    }\n    this.callStackSkipIndex = number;\n  }\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level);\n    if (!logLevel) {\n      if (configuration.validIdentifier(level) && args.length > 0) {\n        // logLevel not found but of valid signature, WARN before fallback to INFO\n        this.log(levels.WARN, 'log4js:logger.log: valid log-level not found as first parameter given:', level);\n        this.log(levels.INFO, `[${level}]`, ...args);\n      } else {\n        // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n        this.log(levels.INFO, level, ...args);\n      }\n    } else if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const error = data.find(item => item instanceof Error);\n    let callStack;\n    if (this.useCallStack) {\n      try {\n        if (error) {\n          callStack = this.parseCallStack(error, this.callStackSkipIndex + baseCallStackSkip);\n        }\n      } catch (_err) {\n        // Ignore Error and use the original method of creating a new Error.\n      }\n      callStack = callStack || this.parseCallStack(new Error(), this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip);\n    }\n    const loggingEvent = new LoggingEvent(this.category, level, data, this.context, callStack, error);\n    clustering.send(loggingEvent);\n  }\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n  removeContext(key) {\n    delete this.context[key];\n  }\n  clearContext() {\n    this.context = {};\n  }\n  setParseCallStackFunction(parseFunction) {\n    if (typeof parseFunction === 'function') {\n      this.parseCallStack = parseFunction;\n    } else if (typeof parseFunction === 'undefined') {\n      this.parseCallStack = defaultParseCallStack;\n    } else {\n      throw new TypeError('Invalid type passed to setParseCallStackFunction');\n    }\n  }\n}\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g => g[1].toUpperCase());\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\nlevels.levels.forEach(addLevelMethods);\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\nmodule.exports = Logger;","map":{"version":3,"names":["debug","require","LoggingEvent","levels","clustering","categories","configuration","stackReg","baseCallStackSkip","defaultErrorCallStackSkip","defaultParseCallStack","data","skipIdx","stacklines","stack","split","slice","length","lineMatch","exec","className","functionName","functionAlias","replace","includes","fileName","lineNumber","parseInt","columnNumber","callStack","join","callerName","console","error","err","Logger","constructor","name","Error","category","context","callStackSkipIndex","parseCallStack","level","getLevel","getLevelForCategory","OFF","setLevelForCategory","useCallStack","getEnableCallStackForCategory","bool","setEnableCallStackForCategory","callStackLinesToSkip","number","TypeError","RangeError","log","args","logLevel","validIdentifier","WARN","INFO","isLevelEnabled","_log","otherLevel","isLessThanOrEqualTo","find","item","_err","loggingEvent","send","addContext","key","value","removeContext","clearContext","setParseCallStackFunction","parseFunction","addLevelMethods","target","levelStrLower","toString","toLowerCase","levelMethod","g","toUpperCase","isLevelMethod","prototype","forEach","addListener","module","exports"],"sources":["C:/Claro/chronos-angular/node_modules/log4js/lib/logger.js"],"sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\n\nconst debug = require('debug')('log4js:logger');\nconst LoggingEvent = require('./LoggingEvent');\nconst levels = require('./levels');\nconst clustering = require('./clustering');\nconst categories = require('./categories');\nconst configuration = require('./configuration');\n\nconst stackReg = /^(?:\\s*)at (?:(.+) \\()?(?:([^(]+?):(\\d+):(\\d+))\\)?$/;\n/**\n * The top entry is the Error\n */\nconst baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\nconst defaultErrorCallStackSkip = 3;\n\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\nfunction defaultParseCallStack(\n  data,\n  skipIdx = defaultErrorCallStackSkip + baseCallStackSkip\n) {\n  try {\n    const stacklines = data.stack.split('\\n').slice(skipIdx);\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n    const lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n    if (lineMatch && lineMatch.length === 5) {\n      // extract class, function and alias names\n      let className = '';\n      let functionName = '';\n      let functionAlias = '';\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        [functionName, functionAlias] = lineMatch[1]\n          .replace(/[[\\]]/g, '')\n          .split(' as ');\n        functionAlias = functionAlias || '';\n\n        if (functionName.includes('.'))\n          [className, functionName] = functionName.split('.');\n      }\n\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className,\n        functionName,\n        functionAlias,\n        callerName: lineMatch[1] || '',\n      };\n      // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n    this.category = name;\n    this.context = {};\n    /** @private */\n    this.callStackSkipIndex = 0;\n    /** @private */\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.OFF\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  get callStackLinesToSkip() {\n    return this.callStackSkipIndex;\n  }\n\n  set callStackLinesToSkip(number) {\n    if (typeof number !== 'number') {\n      throw new TypeError('Must be a number');\n    }\n    if (number < 0) {\n      throw new RangeError('Must be >= 0');\n    }\n    this.callStackSkipIndex = number;\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level);\n    if (!logLevel) {\n      if (configuration.validIdentifier(level) && args.length > 0) {\n        // logLevel not found but of valid signature, WARN before fallback to INFO\n        this.log(\n          levels.WARN,\n          'log4js:logger.log: valid log-level not found as first parameter given:',\n          level\n        );\n        this.log(levels.INFO, `[${level}]`, ...args);\n      } else {\n        // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n        this.log(levels.INFO, level, ...args);\n      }\n    } else if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const error = data.find((item) => item instanceof Error);\n    let callStack;\n    if (this.useCallStack) {\n      try {\n        if (error) {\n          callStack = this.parseCallStack(\n            error,\n            this.callStackSkipIndex + baseCallStackSkip\n          );\n        }\n      } catch (_err) {\n        // Ignore Error and use the original method of creating a new Error.\n      }\n      callStack =\n        callStack ||\n        this.parseCallStack(\n          new Error(),\n          this.callStackSkipIndex +\n            defaultErrorCallStackSkip +\n            baseCallStackSkip\n        );\n    }\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      callStack,\n      error\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    if (typeof parseFunction === 'function') {\n      this.parseCallStack = parseFunction;\n    } else if (typeof parseFunction === 'undefined') {\n      this.parseCallStack = defaultParseCallStack;\n    } else {\n      throw new TypeError('Invalid type passed to setParseCallStackFunction');\n    }\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}