{"ast":null,"code":"const configuration = require('./configuration');\nconst validColours = ['white', 'grey', 'black', 'blue', 'cyan', 'green', 'magenta', 'red', 'yellow'];\nclass Level {\n  constructor(level, levelStr, colour) {\n    this.level = level;\n    this.levelStr = levelStr;\n    this.colour = colour;\n  }\n  toString() {\n    return this.levelStr;\n  }\n\n  /**\n   * converts given String to corresponding Level\n   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level\n   * @param {Level} [defaultLevel] -- default Level, if no String representation\n   * @return {Level}\n   */\n  static getLevel(sArg, defaultLevel) {\n    if (!sArg) {\n      return defaultLevel;\n    }\n    if (sArg instanceof Level) {\n      return sArg;\n    }\n\n    // a json-serialised level won't be an instance of Level (see issue #768)\n    if (sArg instanceof Object && sArg.levelStr) {\n      sArg = sArg.levelStr;\n    }\n    return Level[sArg.toString().toUpperCase()] || defaultLevel;\n  }\n  static addLevels(customLevels) {\n    if (customLevels) {\n      const levels = Object.keys(customLevels);\n      levels.forEach(l => {\n        const levelStr = l.toUpperCase();\n        Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);\n        const existingLevelIndex = Level.levels.findIndex(lvl => lvl.levelStr === levelStr);\n        if (existingLevelIndex > -1) {\n          Level.levels[existingLevelIndex] = Level[levelStr];\n        } else {\n          Level.levels.push(Level[levelStr]);\n        }\n      });\n      Level.levels.sort((a, b) => a.level - b.level);\n    }\n  }\n  isLessThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level <= otherLevel.level;\n  }\n  isGreaterThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level >= otherLevel.level;\n  }\n  isEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level === otherLevel.level;\n  }\n}\nLevel.levels = [];\nLevel.addLevels({\n  ALL: {\n    value: Number.MIN_VALUE,\n    colour: 'grey'\n  },\n  TRACE: {\n    value: 5000,\n    colour: 'blue'\n  },\n  DEBUG: {\n    value: 10000,\n    colour: 'cyan'\n  },\n  INFO: {\n    value: 20000,\n    colour: 'green'\n  },\n  WARN: {\n    value: 30000,\n    colour: 'yellow'\n  },\n  ERROR: {\n    value: 40000,\n    colour: 'red'\n  },\n  FATAL: {\n    value: 50000,\n    colour: 'magenta'\n  },\n  MARK: {\n    value: 9007199254740992,\n    colour: 'grey'\n  },\n  // 2^53\n  OFF: {\n    value: Number.MAX_VALUE,\n    colour: 'grey'\n  }\n});\nconfiguration.addListener(config => {\n  const levelConfig = config.levels;\n  if (levelConfig) {\n    configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), 'levels must be an object');\n    const newLevels = Object.keys(levelConfig);\n    newLevels.forEach(l => {\n      configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name \"${l}\" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);\n      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level \"${l}\" must be an object`);\n      configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level \"${l}\" must have a 'value' property`);\n      configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level \"${l}\".value must have an integer value`);\n      configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level \"${l}\" must have a 'colour' property`);\n      configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level \"${l}\".colour must be one of ${validColours.join(', ')}`);\n    });\n  }\n});\nconfiguration.addListener(config => {\n  Level.addLevels(config.levels);\n});\nmodule.exports = Level;","map":{"version":3,"names":["configuration","require","validColours","Level","constructor","level","levelStr","colour","toString","getLevel","sArg","defaultLevel","Object","toUpperCase","addLevels","customLevels","levels","keys","forEach","l","value","existingLevelIndex","findIndex","lvl","push","sort","a","b","isLessThanOrEqualTo","otherLevel","isGreaterThanOrEqualTo","isEqualTo","ALL","Number","MIN_VALUE","TRACE","DEBUG","INFO","WARN","ERROR","FATAL","MARK","OFF","MAX_VALUE","addListener","config","levelConfig","throwExceptionIf","not","anObject","newLevels","validIdentifier","anInteger","indexOf","join","module","exports"],"sources":["C:/Claro/chronos-angular/node_modules/log4js/lib/levels.js"],"sourcesContent":["const configuration = require('./configuration');\n\nconst validColours = [\n  'white',\n  'grey',\n  'black',\n  'blue',\n  'cyan',\n  'green',\n  'magenta',\n  'red',\n  'yellow',\n];\n\nclass Level {\n  constructor(level, levelStr, colour) {\n    this.level = level;\n    this.levelStr = levelStr;\n    this.colour = colour;\n  }\n\n  toString() {\n    return this.levelStr;\n  }\n\n  /**\n   * converts given String to corresponding Level\n   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level\n   * @param {Level} [defaultLevel] -- default Level, if no String representation\n   * @return {Level}\n   */\n  static getLevel(sArg, defaultLevel) {\n    if (!sArg) {\n      return defaultLevel;\n    }\n\n    if (sArg instanceof Level) {\n      return sArg;\n    }\n\n    // a json-serialised level won't be an instance of Level (see issue #768)\n    if (sArg instanceof Object && sArg.levelStr) {\n      sArg = sArg.levelStr;\n    }\n\n    return Level[sArg.toString().toUpperCase()] || defaultLevel;\n  }\n\n  static addLevels(customLevels) {\n    if (customLevels) {\n      const levels = Object.keys(customLevels);\n      levels.forEach((l) => {\n        const levelStr = l.toUpperCase();\n        Level[levelStr] = new Level(\n          customLevels[l].value,\n          levelStr,\n          customLevels[l].colour\n        );\n        const existingLevelIndex = Level.levels.findIndex(\n          (lvl) => lvl.levelStr === levelStr\n        );\n        if (existingLevelIndex > -1) {\n          Level.levels[existingLevelIndex] = Level[levelStr];\n        } else {\n          Level.levels.push(Level[levelStr]);\n        }\n      });\n      Level.levels.sort((a, b) => a.level - b.level);\n    }\n  }\n\n  isLessThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level <= otherLevel.level;\n  }\n\n  isGreaterThanOrEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level >= otherLevel.level;\n  }\n\n  isEqualTo(otherLevel) {\n    if (typeof otherLevel === 'string') {\n      otherLevel = Level.getLevel(otherLevel);\n    }\n    return this.level === otherLevel.level;\n  }\n}\n\nLevel.levels = [];\nLevel.addLevels({\n  ALL: { value: Number.MIN_VALUE, colour: 'grey' },\n  TRACE: { value: 5000, colour: 'blue' },\n  DEBUG: { value: 10000, colour: 'cyan' },\n  INFO: { value: 20000, colour: 'green' },\n  WARN: { value: 30000, colour: 'yellow' },\n  ERROR: { value: 40000, colour: 'red' },\n  FATAL: { value: 50000, colour: 'magenta' },\n  MARK: { value: 9007199254740992, colour: 'grey' }, // 2^53\n  OFF: { value: Number.MAX_VALUE, colour: 'grey' },\n});\n\nconfiguration.addListener((config) => {\n  const levelConfig = config.levels;\n  if (levelConfig) {\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(configuration.anObject(levelConfig)),\n      'levels must be an object'\n    );\n    const newLevels = Object.keys(levelConfig);\n    newLevels.forEach((l) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.validIdentifier(l)),\n        `level name \"${l}\" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anObject(levelConfig[l])),\n        `level \"${l}\" must be an object`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].value),\n        `level \"${l}\" must have a 'value' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(configuration.anInteger(levelConfig[l].value)),\n        `level \"${l}\".value must have an integer value`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(levelConfig[l].colour),\n        `level \"${l}\" must have a 'colour' property`\n      );\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(validColours.indexOf(levelConfig[l].colour) > -1),\n        `level \"${l}\".colour must be one of ${validColours.join(', ')}`\n      );\n    });\n  }\n});\n\nconfiguration.addListener((config) => {\n  Level.addLevels(config.levels);\n});\n\nmodule.exports = Level;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}